import os
import string
import subprocess

Import('env', 'custom_tests')

# TODO: How to determine these automagically?
cxx_libs = [
    'stlport_static',
    'stlport_shared',
    'gnustl_static',
    'gnustl_shared',
    'c++_static',
    'c++_shared'
]
android_abi_map = {
    'arm'   : 'armeabi',
    'arm64' : 'arm64-v8a',
    'mips'  : 'mips',
    'mips64': 'mips64',
    'x86'   : 'x86',
    'x86_64': 'x86_64'
}

#######################################################
# Extra Android build variables
#######################################################
vars = Variables()
vars.AddVariables(
    EnumVariable('ANDROID_CPU',      'Android target processor',      os.environ.get('ANDROID_CPU', 'arm'), android_abi_map.keys()),
    PathVariable('ANDROID_NDK_PATH', 'Base directory of Android NDK', os.environ.get('ANDROID_NDK_PATH')),
    PathVariable('ANDROID_SDK_PATH', 'Base directory of Android SDK', os.environ.get('ANDROID_SDK_PATH')),
    EnumVariable('ANDROID_STL',      'Android C++ STL to use',        os.environ.get('ANDROID_STL', 'gnustl_shared'), cxx_libs)
)
vars.Update(env)
Help(vars.GenerateHelpText(env))

# ANDROID_NDK_PATH must be set.
if not env.get('ANDROID_NDK_PATH', None):
    if not GetOption('help'):
        print('*** ANDROID_NDK_PATH variable is required.')
        Exit(1)


#######################################################
# Setup toolchain
#######################################################

# We can't use a statically defined toolchain for Android since older versions
# of the NDK use GCC and newer versions of the NDK use Clang.  Thus we need to
# get all the compiler options from the NDK build system.

if not env.GetOption('help'):
    api_levels = [ int(d.split('-')[-1])
                   for d in os.listdir(env['ANDROID_NDK_PATH'] + '/platforms')
                   if (d.split('-')[-1]).isdigit() ]

    api_levels.sort()
    ndk_level = api_levels[-1]

    cmd_suffix = ''
    if host_env['PLATFORM'] == 'win32':
        cmd_suffix = '.cmd'

    curdir = env.Dir('.').srcnode()

    # Do a "test build" using ndk-build on our special Android.mk file to get
    # the compiler and command line options used by Android when building code.
    # (Note: We do not need stderr but setting it suppresses an error on
    # Windows.)
    tb = subprocess.Popen([ env.subst('$ANDROID_NDK_PATH/ndk-build' + cmd_suffix),
                            'APP_BUILD_SCRIPT=%s/support/Android.mk' % curdir,
                            'NDK_PROJECT_PATH=%s/support' % curdir,
                            'APP_ABI=%s' % android_abi_map[env['ANDROID_CPU']],
                            'APP_STL=%s' % env['ANDROID_STL'],
                            'APP_PLATFORM=android-%s' % str(ndk_level),
                            '-n' ],
                          stdout = subprocess.PIPE,
                          stderr = subprocess.PIPE,
                          universal_newlines = True)
    stdoutdata, stderrdata = tb.communicate()

    # Extract the various settings from the ndk-build output.
    line_prefix = 'ANDROID> '
    settings = dict([ map(string.strip, line[len(line_prefix):].split('=', 1))
                      for line in stdoutdata.split('\n')
                      if line.startswith(line_prefix) ])

    if not settings['RANLIB']:
        settings['RANLIB'] = settings['AR'][:-2] + 'ranlib'

    env.Replace(AR = settings['AR'])
    env.Replace(CC = settings['CC'])
    env.Replace(CXX = settings['CXX'])
    env.Replace(LINK = settings['CXX'])
    env.Replace(RANLIB = settings['RANLIB'])
    env.AppendUnique(CFLAGS = settings['CFLAGS'].split())
    env.AppendUnique(CXXFLAGS = settings['CXXFLAGS'].split())
    env.AppendUnique(LINKFLAGS = settings['LDFLAGS'].split())

    if env['NDEBUG'] or env['PRODUCTION']:
        env.MergeFlags(settings['release_FLAGS'].split())
    else:
        env.MergeFlags(settings['debug_FLAGS'].split())

    env.Append(LIBPATH = [ settings['SYSROOT'] + '/usr/lib' ])
    env.Append(LINKFLAGS = [ '--sysroot=' + settings['SYSROOT'] ])
    for path in settings['INCLUDES'].split():
        env.Append(CCFLAGS = [ '-isystem', path ])
    env.Append(CCFLAGS = [ '-isystem', settings['SYSROOT'] + '/usr/include' ])

    config = Configure(env, custom_tests = custom_tests)

    config.CheckCCFlag('-pie')
    config.CheckCCFlag('-fPIE')

    config.CheckLib('stdc++')
    config.CheckLib('log')
    config.CheckLib('gcc')

    config.CheckLinkFlag('-Wl,--gc-sections')
    config.CheckLinkFlag('-Wl,-z,nocopyreloc')

    if not settings['CC'] == 'clang':
        # Clang complains about the -pie option when linking so only use this option for GCC.
        config.CheckLinkFlag('-pie')
        config.CheckLinkFlag('-fPIE')

    env = config.Finish()
